# -*- coding: utf-8 -*-
# Symbolic Functions for N = 4 (General Symm. Stochastic)
# Generated by script

import math
import numpy as np


# --------------------------------------------------------------------------
# Value Function (S1_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S1_n4(x_vec):
    """Calculates S_1 for n=4 general symm. stochastic matrix.
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: float: S_1 value.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # S_k CSE Defs

    # Final S_k Calculation
    result = 2*(-x_0_1 - x_0_2 - x_0_3 - x_1_2 - x_1_3 - x_2_3 + 2)
    return result



# --------------------------------------------------------------------------
# Jacobian Function (S1_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S1_n4_jacobian(x_vec):
    """Calculates Jacobian of S_1 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: list: Gradient vector.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Jacobian CSE Defs

    # Final Gradient Calculation
    gradient = [
        -2,
        -2,
        -2,
        -2,
        -2,
        -2
    ]
    return gradient



# --------------------------------------------------------------------------
# Hessian Function (S1_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S1_n4_hessian(x_vec):
    """Calculates Hessian matrix of S_1 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: numpy.ndarray: Hessian matrix (6x6).
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Hessian CSE Defs

    # Final Hessian Calculation
    hessian_np = np.zeros((6, 6)) # Initialize
    hessian_np[0, 0] = 0
    hessian_np[0, 1] = 0
    hessian_np[0, 2] = 0
    hessian_np[0, 3] = 0
    hessian_np[0, 4] = 0
    hessian_np[0, 5] = 0
    hessian_np[1, 0] = 0
    hessian_np[1, 1] = 0
    hessian_np[1, 2] = 0
    hessian_np[1, 3] = 0
    hessian_np[1, 4] = 0
    hessian_np[1, 5] = 0
    hessian_np[2, 0] = 0
    hessian_np[2, 1] = 0
    hessian_np[2, 2] = 0
    hessian_np[2, 3] = 0
    hessian_np[2, 4] = 0
    hessian_np[2, 5] = 0
    hessian_np[3, 0] = 0
    hessian_np[3, 1] = 0
    hessian_np[3, 2] = 0
    hessian_np[3, 3] = 0
    hessian_np[3, 4] = 0
    hessian_np[3, 5] = 0
    hessian_np[4, 0] = 0
    hessian_np[4, 1] = 0
    hessian_np[4, 2] = 0
    hessian_np[4, 3] = 0
    hessian_np[4, 4] = 0
    hessian_np[4, 5] = 0
    hessian_np[5, 0] = 0
    hessian_np[5, 1] = 0
    hessian_np[5, 2] = 0
    hessian_np[5, 3] = 0
    hessian_np[5, 4] = 0
    hessian_np[5, 5] = 0
    return hessian_np



# --------------------------------------------------------------------------
# Value Function (S2_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S2_n4(x_vec):
    """Calculates S_2 for n=4 general symm. stochastic matrix.
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: float: S_2 value.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # S_k CSE Defs
    x0 = 3*x_0_1
    x1 = 3*x_0_2
    x2 = 3*x_0_3
    x3 = 3*x_1_2
    # Final S_k Calculation
    result = x0*x_0_2 + x0*x_0_3 + x0*x_1_2 + x0*x_1_3 + x1*x_0_3 + x1*x_1_2 + x1*x_2_3 + x2*x_1_3 + x2*x_2_3 + x3*x_1_3 + x3*x_2_3 + 4*x_0_1*x_2_3 - 6*x_0_1 + 4*x_0_2*x_1_3 - 6*x_0_2 + 4*x_0_3*x_1_2 - 6*x_0_3 - 6*x_1_2 + 3*x_1_3*x_2_3 - 6*x_1_3 - 6*x_2_3 + 6
    return result



# --------------------------------------------------------------------------
# Jacobian Function (S2_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S2_n4_jacobian(x_vec):
    """Calculates Jacobian of S_2 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: list: Gradient vector.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Jacobian CSE Defs
    x0 = 3*x_0_3 + 3*x_1_2 - 6
    x1 = 3*x_0_2 + 3*x_1_3
    x2 = x0 + x1
    x3 = 3*x_0_1 + 3*x_2_3
    x4 = x0 + x3
    x5 = x1 + x3 - 6
    # Final Gradient Calculation
    gradient = [
        x2 + 4*x_2_3,
        x4 + 4*x_1_3,
        x5 + 4*x_1_2,
        x5 + 4*x_0_3,
        x4 + 4*x_0_2,
        x2 + 4*x_0_1
    ]
    return gradient



# --------------------------------------------------------------------------
# Hessian Function (S2_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S2_n4_hessian(x_vec):
    """Calculates Hessian matrix of S_2 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: numpy.ndarray: Hessian matrix (6x6).
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Hessian CSE Defs

    # Final Hessian Calculation
    hessian_np = np.zeros((6, 6)) # Initialize
    hessian_np[0, 0] = 0
    hessian_np[0, 1] = 3
    hessian_np[0, 2] = 3
    hessian_np[0, 3] = 3
    hessian_np[0, 4] = 3
    hessian_np[0, 5] = 4
    hessian_np[1, 0] = 3
    hessian_np[1, 1] = 0
    hessian_np[1, 2] = 3
    hessian_np[1, 3] = 3
    hessian_np[1, 4] = 4
    hessian_np[1, 5] = 3
    hessian_np[2, 0] = 3
    hessian_np[2, 1] = 3
    hessian_np[2, 2] = 0
    hessian_np[2, 3] = 4
    hessian_np[2, 4] = 3
    hessian_np[2, 5] = 3
    hessian_np[3, 0] = 3
    hessian_np[3, 1] = 3
    hessian_np[3, 2] = 4
    hessian_np[3, 3] = 0
    hessian_np[3, 4] = 3
    hessian_np[3, 5] = 3
    hessian_np[4, 0] = 3
    hessian_np[4, 1] = 4
    hessian_np[4, 2] = 3
    hessian_np[4, 3] = 3
    hessian_np[4, 4] = 0
    hessian_np[4, 5] = 3
    hessian_np[5, 0] = 4
    hessian_np[5, 1] = 3
    hessian_np[5, 2] = 3
    hessian_np[5, 3] = 3
    hessian_np[5, 4] = 3
    hessian_np[5, 5] = 0
    return hessian_np



# --------------------------------------------------------------------------
# Value Function (S3_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S3_n4(x_vec):
    """Calculates S_3 for n=4 general symm. stochastic matrix.
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: float: S_3 value.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # S_k CSE Defs
    x0 = 2*x_0_1
    x1 = x_0_2*x_1_3
    x2 = 2*x_0_1*x_2_3
    x3 = x_0_3*x_1_2
    x4 = 2*x_0_2
    x5 = 2*x1
    x6 = 2*x3
    # Final S_k Calculation
    result = -2*x0*x1 - 2*x0*x3 - 2*x0*x_0_2*x_0_3 - 2*x0*x_1_2*x_1_3 - 2*x2*x_0_2 - 2*x2*x_0_3 - 2*x2*x_1_2 - 2*x2*x_1_3 - 2*x3*x4 - 2*x4*x_1_2*x_2_3 - 2*x5*x_0_3 - 2*x5*x_1_2 - 2*x5*x_2_3 - 2*x6*x_1_3 - 2*x6*x_2_3 + 6*x_0_1*x_0_2 + 6*x_0_1*x_0_3 + 6*x_0_1*x_1_2 + 6*x_0_1*x_1_3 + 8*x_0_1*x_2_3 - 6*x_0_1 + 6*x_0_2*x_0_3 + 6*x_0_2*x_1_2 + 8*x_0_2*x_1_3 + 6*x_0_2*x_2_3 - 6*x_0_2 + 8*x_0_3*x_1_2 - 4*x_0_3*x_1_3*x_2_3 + 6*x_0_3*x_1_3 + 6*x_0_3*x_2_3 - 6*x_0_3 + 6*x_1_2*x_1_3 + 6*x_1_2*x_2_3 - 6*x_1_2 + 6*x_1_3*x_2_3 - 6*x_1_3 - 6*x_2_3 + 4
    return result



# --------------------------------------------------------------------------
# Jacobian Function (S3_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S3_n4_jacobian(x_vec):
    """Calculates Jacobian of S_3 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: list: Gradient vector.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Jacobian CSE Defs
    x0 = -3*x_0_3
    x1 = -3*x_1_2
    x2 = 2*x_0_3
    x3 = x2*x_1_2
    x4 = 2*x_1_2
    x5 = x4*x_1_3
    x6 = x4*x_2_3
    x7 = 2*x_1_3
    x8 = x7*x_2_3
    x9 = x0 + x1 + x3 + x5 + x6 + x8 + 3
    x10 = 2*x_0_2
    x11 = x10*x_0_3
    x12 = x10*x_2_3
    x13 = x2*x_2_3
    x14 = x10*x_1_3 - 3*x_0_2 - 3*x_1_3
    x15 = x11 + x12 + x13 + x14
    x16 = 2*x_0_1*x_2_3 - 3*x_0_1 - 3*x_2_3
    x17 = x2*x_0_1 + x2*x_1_3 + x7*x_0_1
    x18 = x16 + x17
    x19 = x10*x_0_1
    x20 = x4*x_0_1
    x21 = x10*x_1_2
    x22 = x16 + x19 + x20 + x21 + 3
    x23 = x0 + x1 + x3
    # Final Gradient Calculation
    gradient = [
        -2*x15 - 2*x9 + 8*x_2_3,
        -2*x18 - 2*x9 + 8*x_1_3,
        -2*x14 - 2*x22 - 2*x5 - 2*x6 - 2*x8 + 8*x_1_2,
        -2*x15 - 2*x18 + 8*x_0_3 - 6,
        -2*x11 - 2*x12 - 2*x13 - 2*x22 - 2*x23 + 8*x_0_2,
        -2*x14 - 2*x17 - 2*x19 - 2*x20 - 2*x21 - 2*x23 + 8*x_0_1 - 6
    ]
    return gradient



# --------------------------------------------------------------------------
# Hessian Function (S3_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S3_n4_hessian(x_vec):
    """Calculates Hessian matrix of S_3 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: numpy.ndarray: Hessian matrix (6x6).
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Hessian CSE Defs
    x0 = 2*x_0_3
    x1 = 2*x_1_3
    x2 = 2*x_2_3 - 3
    x3 = -2*x0 - 2*x1 - 2*x2
    x4 = 2*x_0_2
    x5 = 2*x_1_2
    x6 = -2*x2 - 2*x4 - 2*x5
    x7 = x_0_3 + x_1_2 - 2
    x8 = x_0_2 + x_1_3
    x9 = -4*x7 - 4*x8
    x10 = 2*x_0_1 - 3
    x11 = -2*x1 - 2*x10 - 2*x5
    x12 = x_0_1 + x_2_3
    x13 = -4*x12 - 4*x7
    x14 = -4*x12 - 4*x8 + 8
    x15 = -2*x0 - 2*x10 - 2*x4
    # Final Hessian Calculation
    hessian_np = np.zeros((6, 6)) # Initialize
    hessian_np[0, 0] = 0
    hessian_np[0, 1] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 6
    hessian_np[0, 2] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 6
    hessian_np[0, 3] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 6
    hessian_np[0, 4] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 6
    hessian_np[0, 5] = -4*x_0_2 - 4*x_0_3 - 4*x_1_2 - 4*x_1_3 + 8
    hessian_np[1, 0] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 6
    hessian_np[1, 1] = 0
    hessian_np[1, 2] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 6
    hessian_np[1, 3] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 6
    hessian_np[1, 4] = -4*x_0_1 - 4*x_0_3 - 4*x_1_2 - 4*x_2_3 + 8
    hessian_np[1, 5] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 6
    hessian_np[2, 0] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 6
    hessian_np[2, 1] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 6
    hessian_np[2, 2] = 0
    hessian_np[2, 3] = -4*x_0_1 - 4*x_0_2 - 4*x_1_3 - 4*x_2_3 + 8
    hessian_np[2, 4] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 6
    hessian_np[2, 5] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 6
    hessian_np[3, 0] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 6
    hessian_np[3, 1] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 6
    hessian_np[3, 2] = -4*x_0_1 - 4*x_0_2 - 4*x_1_3 - 4*x_2_3 + 8
    hessian_np[3, 3] = 0
    hessian_np[3, 4] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 6
    hessian_np[3, 5] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 6
    hessian_np[4, 0] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 6
    hessian_np[4, 1] = -4*x_0_1 - 4*x_0_3 - 4*x_1_2 - 4*x_2_3 + 8
    hessian_np[4, 2] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 6
    hessian_np[4, 3] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 6
    hessian_np[4, 4] = 0
    hessian_np[4, 5] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 6
    hessian_np[5, 0] = -4*x_0_2 - 4*x_0_3 - 4*x_1_2 - 4*x_1_3 + 8
    hessian_np[5, 1] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 6
    hessian_np[5, 2] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 6
    hessian_np[5, 3] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 6
    hessian_np[5, 4] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 6
    hessian_np[5, 5] = 0
    return hessian_np



# --------------------------------------------------------------------------
# Value Function (S4_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S4_n4(x_vec):
    """Calculates S_4 for n=4 general symm. stochastic matrix.
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: float: S_4 value.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # S_k CSE Defs
    x0 = 4*x_0_1
    x1 = x_0_2*x_1_3
    x2 = x0*x_2_3
    x3 = x_0_3*x_1_2
    x4 = x_1_3*x_2_3
    x5 = 4*x3
    x6 = 4*x1
    x7 = 4*x_0_2
    # Final S_k Calculation
    result = -x0*x1 - x0*x3 - x0*x4 - x0*x_0_2*x_0_3 - x0*x_1_2*x_1_3 - x2*x_0_2 - x2*x_0_3 - x2*x_1_2 - x4*x7 - 4*x4*x_0_3 - x5*x_0_2 - x5*x_1_3 - x5*x_2_3 - x6*x_0_3 - x6*x_1_2 - x7*x_1_2*x_2_3 + 3*x_0_1*x_0_2 + 3*x_0_1*x_0_3 + 3*x_0_1*x_1_2 + 3*x_0_1*x_1_3 + 4*x_0_1*x_2_3 - 2*x_0_1 + 3*x_0_2*x_0_3 + 3*x_0_2*x_1_2 + 4*x_0_2*x_1_3 + 3*x_0_2*x_2_3 - 2*x_0_2 + 4*x_0_3*x_1_2 + 3*x_0_3*x_1_3 + 3*x_0_3*x_2_3 - 2*x_0_3 + 3*x_1_2*x_1_3 + 3*x_1_2*x_2_3 - 2*x_1_2 + 3*x_1_3*x_2_3 - 2*x_1_3 - 2*x_2_3 + 1
    return result



# --------------------------------------------------------------------------
# Jacobian Function (S4_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S4_n4_jacobian(x_vec):
    """Calculates Jacobian of S_4 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: list: Gradient vector.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Jacobian CSE Defs
    x0 = -3*x_0_3
    x1 = -3*x_1_2
    x2 = 4*x_1_2
    x3 = x2*x_0_3
    x4 = 4*x_1_3
    x5 = x4*x_1_2
    x6 = 4*x_2_3
    x7 = x6*x_1_2
    x8 = x6*x_1_3
    x9 = x0 + x1 + x3 + x5 + x7 + x8 + 2
    x10 = 4*x_0_3
    x11 = x10*x_0_2
    x12 = x6*x_0_2
    x13 = x6*x_0_3
    x14 = x4*x_0_2 - 3*x_0_2 - 3*x_1_3
    x15 = x11 + x12 + x13 + x14
    x16 = x6*x_0_1 - 3*x_0_1 - 3*x_2_3
    x17 = x10*x_0_1 + x4*x_0_1 + x4*x_0_3
    x18 = x16 + x17
    x19 = 4*x_0_1*x_0_2
    x20 = x2*x_0_1
    x21 = x2*x_0_2
    x22 = x16 + x19 + x20 + x21 + 2
    x23 = x0 + x1 + x3
    # Final Gradient Calculation
    gradient = [
        -x15 - x9 + 4*x_2_3,
        -x18 - x9 + 4*x_1_3,
        -x14 - x22 - x5 - x7 - x8 + 4*x_1_2,
        -x15 - x18 + 4*x_0_3 - 2,
        -x11 - x12 - x13 - x22 - x23 + 4*x_0_2,
        -x14 - x17 - x19 - x20 - x21 - x23 + 4*x_0_1 - 2
    ]
    return gradient



# --------------------------------------------------------------------------
# Hessian Function (S4_n4)
# Input: x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
# --------------------------------------------------------------------------
def calculate_S4_n4_hessian(x_vec):
    """Calculates Hessian matrix of S_4 (n=4).
    Args:
        x_vec (numpy array or list/tuple): Input vector of length 6
           containing the strict upper triangle elements in row-wise order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3
           Diagonal elements are determined by stochastic constraint.
    
    Returns: numpy.ndarray: Hessian matrix (6x6).
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]
    # Hessian CSE Defs
    x0 = 4*x_0_3
    x1 = 4*x_1_3
    x2 = 4*x_2_3 - 3
    x3 = -x0 - x1 - x2
    x4 = 4*x_0_2
    x5 = 4*x_1_2
    x6 = -x2 - x4 - x5
    x7 = x_0_3 + x_1_2 - 1
    x8 = x_0_2 + x_1_3
    x9 = -4*x7 - 4*x8
    x10 = 4*x_0_1 - 3
    x11 = -x1 - x10 - x5
    x12 = x_0_1 + x_2_3
    x13 = -4*x12 - 4*x7
    x14 = -4*x12 - 4*x8 + 4
    x15 = -x0 - x10 - x4
    # Final Hessian Calculation
    hessian_np = np.zeros((6, 6)) # Initialize
    hessian_np[0, 0] = 0
    hessian_np[0, 1] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 3
    hessian_np[0, 2] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 3
    hessian_np[0, 3] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 3
    hessian_np[0, 4] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 3
    hessian_np[0, 5] = -4*x_0_2 - 4*x_0_3 - 4*x_1_2 - 4*x_1_3 + 4
    hessian_np[1, 0] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 3
    hessian_np[1, 1] = 0
    hessian_np[1, 2] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 3
    hessian_np[1, 3] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 3
    hessian_np[1, 4] = -4*x_0_1 - 4*x_0_3 - 4*x_1_2 - 4*x_2_3 + 4
    hessian_np[1, 5] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 3
    hessian_np[2, 0] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 3
    hessian_np[2, 1] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 3
    hessian_np[2, 2] = 0
    hessian_np[2, 3] = -4*x_0_1 - 4*x_0_2 - 4*x_1_3 - 4*x_2_3 + 4
    hessian_np[2, 4] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 3
    hessian_np[2, 5] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 3
    hessian_np[3, 0] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 3
    hessian_np[3, 1] = -4*x_0_3 - 4*x_1_3 - 4*x_2_3 + 3
    hessian_np[3, 2] = -4*x_0_1 - 4*x_0_2 - 4*x_1_3 - 4*x_2_3 + 4
    hessian_np[3, 3] = 0
    hessian_np[3, 4] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 3
    hessian_np[3, 5] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 3
    hessian_np[4, 0] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 3
    hessian_np[4, 1] = -4*x_0_1 - 4*x_0_3 - 4*x_1_2 - 4*x_2_3 + 4
    hessian_np[4, 2] = -4*x_0_2 - 4*x_1_2 - 4*x_2_3 + 3
    hessian_np[4, 3] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 3
    hessian_np[4, 4] = 0
    hessian_np[4, 5] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 3
    hessian_np[5, 0] = -4*x_0_2 - 4*x_0_3 - 4*x_1_2 - 4*x_1_3 + 4
    hessian_np[5, 1] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 3
    hessian_np[5, 2] = -4*x_0_1 - 4*x_1_2 - 4*x_1_3 + 3
    hessian_np[5, 3] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 3
    hessian_np[5, 4] = -4*x_0_1 - 4*x_0_2 - 4*x_0_3 + 3
    hessian_np[5, 5] = 0
    return hessian_np




# --- Basic Test Usage ---
if __name__ == '__main__':
    print("\n" + "-"*20); print("--- Running Basic Tests for N=4 (General) ---"); print("-" * 20)
    x_test = (0.25, 0.25, 0.25, 0.25, 0.25, 0.25) # Test vector for the 1/N matrix
    print(f"Test input vector (len 6): {x_test}")

    s_k_expected = {1: 1.0, 2: 0.0, 3: 0.0, 4: 0.0}

    print("\n--- Testing S_1 ---")
    # Value
    val = None
    try:
        val = calculate_S1_n4(x_test)
        exp_val = s_k_expected.get(1, None)
        print(f"  calculate_S1_n4(x_test) = {val:.6e}")
        if exp_val is not None:
            check_result = 'PASS' if abs(val - exp_val) < 1e-9 else 'FAIL'
            print(f"    Check vs Expected ({exp_val:.1f}): {check_result}")
        else: print("    (No expected value for check)")
    except Exception as e: print(f"  Error testing calculate_S1_n4: {e}")

    # Jacobian
    try: jac = calculate_S1_n4_jacobian(x_test); print(f"  calculate_S1_n4_jacobian(x_test) returned vector length {len(jac)}"); is_zero = all(abs(j) < 1e-9 for j in jac); print(f"    Check if zero vector: {is_zero}")
    except Exception as e: print(f"  Error testing calculate_S1_n4_jacobian: {e}")

    # Hessian
    try: hess = calculate_S1_n4_hessian(x_test); print(f"  calculate_S1_n4_hessian(x_test) returned matrix shape {hess.shape if hasattr(hess,'shape') else 'N/A'}")
    except Exception as e: print(f"  Error testing calculate_S1_n4_hessian: {e}")

    print("\n--- Testing S_2 ---")
    # Value
    val = None
    try:
        val = calculate_S2_n4(x_test)
        exp_val = s_k_expected.get(2, None)
        print(f"  calculate_S2_n4(x_test) = {val:.6e}")
        if exp_val is not None:
            check_result = 'PASS' if abs(val - exp_val) < 1e-9 else 'FAIL'
            print(f"    Check vs Expected ({exp_val:.1f}): {check_result}")
        else: print("    (No expected value for check)")
    except Exception as e: print(f"  Error testing calculate_S2_n4: {e}")

    # Jacobian
    try: jac = calculate_S2_n4_jacobian(x_test); print(f"  calculate_S2_n4_jacobian(x_test) returned vector length {len(jac)}"); is_zero = all(abs(j) < 1e-9 for j in jac); print(f"    Check if zero vector: {is_zero}")
    except Exception as e: print(f"  Error testing calculate_S2_n4_jacobian: {e}")

    # Hessian
    try: hess = calculate_S2_n4_hessian(x_test); print(f"  calculate_S2_n4_hessian(x_test) returned matrix shape {hess.shape if hasattr(hess,'shape') else 'N/A'}")
    except Exception as e: print(f"  Error testing calculate_S2_n4_hessian: {e}")

    print("\n--- Testing S_3 ---")
    # Value
    val = None
    try:
        val = calculate_S3_n4(x_test)
        exp_val = s_k_expected.get(3, None)
        print(f"  calculate_S3_n4(x_test) = {val:.6e}")
        if exp_val is not None:
            check_result = 'PASS' if abs(val - exp_val) < 1e-9 else 'FAIL'
            print(f"    Check vs Expected ({exp_val:.1f}): {check_result}")
        else: print("    (No expected value for check)")
    except Exception as e: print(f"  Error testing calculate_S3_n4: {e}")

    # Jacobian
    try: jac = calculate_S3_n4_jacobian(x_test); print(f"  calculate_S3_n4_jacobian(x_test) returned vector length {len(jac)}"); is_zero = all(abs(j) < 1e-9 for j in jac); print(f"    Check if zero vector: {is_zero}")
    except Exception as e: print(f"  Error testing calculate_S3_n4_jacobian: {e}")

    # Hessian
    try: hess = calculate_S3_n4_hessian(x_test); print(f"  calculate_S3_n4_hessian(x_test) returned matrix shape {hess.shape if hasattr(hess,'shape') else 'N/A'}")
    except Exception as e: print(f"  Error testing calculate_S3_n4_hessian: {e}")

    print("\n--- Testing S_4 ---")
    # Value
    val = None
    try:
        val = calculate_S4_n4(x_test)
        exp_val = s_k_expected.get(4, None)
        print(f"  calculate_S4_n4(x_test) = {val:.6e}")
        if exp_val is not None:
            check_result = 'PASS' if abs(val - exp_val) < 1e-9 else 'FAIL'
            print(f"    Check vs Expected ({exp_val:.1f}): {check_result}")
        else: print("    (No expected value for check)")
    except Exception as e: print(f"  Error testing calculate_S4_n4: {e}")

    # Jacobian
    try: jac = calculate_S4_n4_jacobian(x_test); print(f"  calculate_S4_n4_jacobian(x_test) returned vector length {len(jac)}"); is_zero = all(abs(j) < 1e-9 for j in jac); print(f"    Check if zero vector: {is_zero}")
    except Exception as e: print(f"  Error testing calculate_S4_n4_jacobian: {e}")

    # Hessian
    try: hess = calculate_S4_n4_hessian(x_test); print(f"  calculate_S4_n4_hessian(x_test) returned matrix shape {hess.shape if hasattr(hess,'shape') else 'N/A'}")
    except Exception as e: print(f"  Error testing calculate_S4_n4_hessian: {e}")
