# -*- coding: utf-8 -*-
# Separated Value, Jacobian, & Hessian Functions for N = 3 (matrix_type='sub_sniep')
# Generated by symbolic_minors_generator.py
# DO NOT EDIT MANUALLY

import numpy as np
import numba

# --- Functions for S_1 ---

@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n3(x_vec):
    """Calculates the value of S_1 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    return x_0_0 + x_1_1 + x_2_2



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_1 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    return np.array([1,
        0,
        0,
        1,
        0,
        1])



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n3_hessian(x_vec):
    """Calculates the Hessian matrix of S_1 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    hessian = np.empty((6, 6))
    hessian[0, 0] = 0
    hessian[0, 1] = 0
    hessian[0, 2] = 0
    hessian[0, 3] = 0
    hessian[0, 4] = 0
    hessian[0, 5] = 0
    hessian[1, 0] = 0
    hessian[1, 1] = 0
    hessian[1, 2] = 0
    hessian[1, 3] = 0
    hessian[1, 4] = 0
    hessian[1, 5] = 0
    hessian[2, 0] = 0
    hessian[2, 1] = 0
    hessian[2, 2] = 0
    hessian[2, 3] = 0
    hessian[2, 4] = 0
    hessian[2, 5] = 0
    hessian[3, 0] = 0
    hessian[3, 1] = 0
    hessian[3, 2] = 0
    hessian[3, 3] = 0
    hessian[3, 4] = 0
    hessian[3, 5] = 0
    hessian[4, 0] = 0
    hessian[4, 1] = 0
    hessian[4, 2] = 0
    hessian[4, 3] = 0
    hessian[4, 4] = 0
    hessian[4, 5] = 0
    hessian[5, 0] = 0
    hessian[5, 1] = 0
    hessian[5, 2] = 0
    hessian[5, 3] = 0
    hessian[5, 4] = 0
    hessian[5, 5] = 0
    return hessian


# --- Functions for S_2 ---

@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n3(x_vec):
    """Calculates the value of S_2 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    return x_0_0*x_1_1 + x_0_0*x_2_2 - x_0_1**2 - x_0_2**2 + x_1_1*x_2_2 - x_1_2**2



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_2 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    return np.array([x_1_1 + x_2_2,
        -2*x_0_1,
        -2*x_0_2,
        x_0_0 + x_2_2,
        -2*x_1_2,
        x_0_0 + x_1_1])



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n3_hessian(x_vec):
    """Calculates the Hessian matrix of S_2 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    hessian = np.empty((6, 6))
    hessian[0, 0] = 0
    hessian[0, 1] = 0
    hessian[0, 2] = 0
    hessian[0, 3] = 1
    hessian[0, 4] = 0
    hessian[0, 5] = 1
    hessian[1, 0] = 0
    hessian[1, 1] = -2
    hessian[1, 2] = 0
    hessian[1, 3] = 0
    hessian[1, 4] = 0
    hessian[1, 5] = 0
    hessian[2, 0] = 0
    hessian[2, 1] = 0
    hessian[2, 2] = -2
    hessian[2, 3] = 0
    hessian[2, 4] = 0
    hessian[2, 5] = 0
    hessian[3, 0] = 1
    hessian[3, 1] = 0
    hessian[3, 2] = 0
    hessian[3, 3] = 0
    hessian[3, 4] = 0
    hessian[3, 5] = 1
    hessian[4, 0] = 0
    hessian[4, 1] = 0
    hessian[4, 2] = 0
    hessian[4, 3] = 0
    hessian[4, 4] = -2
    hessian[4, 5] = 0
    hessian[5, 0] = 1
    hessian[5, 1] = 0
    hessian[5, 2] = 0
    hessian[5, 3] = 1
    hessian[5, 4] = 0
    hessian[5, 5] = 0
    return hessian


# --- Functions for S_3 ---

@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n3(x_vec):
    """Calculates the value of S_3 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    return x_0_0*x_1_1*x_2_2 - x_0_0*x_1_2**2 - x_0_1**2*x_2_2 + 2*x_0_1*x_0_2*x_1_2 - x_0_2**2*x_1_1



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_3 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]

    return np.array([x_1_1*x_2_2 - x_1_2**2,
        2*(-x_0_1*x_2_2 + x_0_2*x_1_2),
        2*(x_0_1*x_1_2 - x_0_2*x_1_1),
        x_0_0*x_2_2 - x_0_2**2,
        2*(-x_0_0*x_1_2 + x_0_1*x_0_2),
        x_0_0*x_1_1 - x_0_1**2])



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n3_hessian(x_vec):
    """Calculates the Hessian matrix of S_3 for n=3."""
    x_0_0 = x_vec[0]
    x_0_1 = x_vec[1]
    x_0_2 = x_vec[2]
    x_1_1 = x_vec[3]
    x_1_2 = x_vec[4]
    x_2_2 = x_vec[5]
    x0 = 2*x_1_2
    x1 = -x0
    x2 = 2*x_0_2
    x3 = 2*x_0_1
    x4 = -x3
    x5 = -x2
    hessian = np.empty((6, 6))
    hessian[0, 0] = 0
    hessian[0, 1] = 0
    hessian[0, 2] = 0
    hessian[0, 3] = x_2_2
    hessian[0, 4] = x1
    hessian[0, 5] = x_1_1
    hessian[1, 0] = 0
    hessian[1, 1] = -2*x_2_2
    hessian[1, 2] = x0
    hessian[1, 3] = 0
    hessian[1, 4] = x2
    hessian[1, 5] = x4
    hessian[2, 0] = 0
    hessian[2, 1] = x0
    hessian[2, 2] = -2*x_1_1
    hessian[2, 3] = x5
    hessian[2, 4] = x3
    hessian[2, 5] = 0
    hessian[3, 0] = x_2_2
    hessian[3, 1] = 0
    hessian[3, 2] = x5
    hessian[3, 3] = 0
    hessian[3, 4] = 0
    hessian[3, 5] = x_0_0
    hessian[4, 0] = x1
    hessian[4, 1] = x2
    hessian[4, 2] = x3
    hessian[4, 3] = 0
    hessian[4, 4] = -2*x_0_0
    hessian[4, 5] = 0
    hessian[5, 0] = x_1_1
    hessian[5, 1] = x4
    hessian[5, 2] = 0
    hessian[5, 3] = x_0_0
    hessian[5, 4] = 0
    hessian[5, 5] = 0
    return hessian


