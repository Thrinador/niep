# -*- coding: utf-8 -*-
# Combined Value & Jacobian Functions for N = 4 (matrix_type='sniep')
# Generated by symbolic_minors_generator.py using Newton's Sums
# Optimized for use with scipy.optimize.minimize(..., jac=True)
# DO NOT EDIT MANUALLY

import numpy as np
import numba
# The 'math' module is not needed as Numba recognizes standard functions


# --------------------------------------------------------------------------
# Combined Value and Jacobian Function (S1_n4)
# Generated for use with scipy.optimize.minimize(..., jac=True)
# --------------------------------------------------------------------------
@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n4_value_and_jac(x_vec):
    """Calculates both the value and Jacobian of S_1 for n=4.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3

    Returns:
        (float, numpy.ndarray): A tuple containing the S_1 value and its gradient.
    """
    # Assign variables from input vector
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]

    # Common subexpressions for value and gradient


    # Final calculations
    result = 2*(-x_0_1 - x_0_2 - x_0_3 - x_1_2 - x_1_3 - x_2_3 + 2)
    gradient = np.array([
        -2,
        -2,
        -2,
        -2,
        -2,
        -2
    ])
    
    return result, gradient



# --------------------------------------------------------------------------
# Combined Value and Jacobian Function (S2_n4)
# Generated for use with scipy.optimize.minimize(..., jac=True)
# --------------------------------------------------------------------------
@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n4_value_and_jac(x_vec):
    """Calculates both the value and Jacobian of S_2 for n=4.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3

    Returns:
        (float, numpy.ndarray): A tuple containing the S_2 value and its gradient.
    """
    # Assign variables from input vector
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]

    # Common subexpressions for value and gradient
    x0 = 3*x_0_2
    x1 = 3*x_0_3
    x2 = 3*x_1_2
    x3 = 3*x_1_3
    x4 = 4*x_2_3
    x5 = 4*x_1_3
    x6 = 4*x_1_2
    x7 = x1 + x2 - 6
    x8 = x0 + x3
    x9 = x7 + x8
    x10 = 3*x_0_1 + 3*x_2_3
    x11 = x10 + x7
    x12 = x10 + x8 - 6

    # Final calculations
    result = x0*x_0_1 + x0*x_0_3 + x0*x_1_2 + x0*x_2_3 + x1*x_0_1 + x1*x_1_3 + x1*x_2_3 + x2*x_0_1 + x2*x_1_3 + x2*x_2_3 + x3*x_0_1 + x3*x_2_3 + x4*x_0_1 + x5*x_0_2 + x6*x_0_3 - 6*x_0_1 - 6*x_0_2 - 6*x_0_3 - 6*x_1_2 - 6*x_1_3 - 6*x_2_3 + 6
    gradient = np.array([
        x4 + x9,
        x11 + x5,
        x12 + x6,
        x12 + 4*x_0_3,
        x11 + 4*x_0_2,
        x9 + 4*x_0_1
    ])
    
    return result, gradient



# --------------------------------------------------------------------------
# Combined Value and Jacobian Function (S3_n4)
# Generated for use with scipy.optimize.minimize(..., jac=True)
# --------------------------------------------------------------------------
@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n4_value_and_jac(x_vec):
    """Calculates both the value and Jacobian of S_3 for n=4.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3

    Returns:
        (float, numpy.ndarray): A tuple containing the S_3 value and its gradient.
    """
    # Assign variables from input vector
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]

    # Common subexpressions for value and gradient
    x0 = 3*x_0_1
    x1 = 3*x_0_2
    x2 = 3*x_0_3
    x3 = 3*x_1_2
    x4 = 3*x_1_3
    x5 = 3*x_2_3
    x6 = 2*x_0_2
    x7 = x6*x_0_3
    x8 = x6*x_1_3
    x9 = x6*x_2_3
    x10 = 2*x_0_3
    x11 = x10*x_1_2
    x12 = x10*x_2_3
    x13 = 2*x_1_2
    x14 = x13*x_1_3
    x15 = x13*x_2_3
    x16 = 2*x_1_3
    x17 = x16*x_2_3
    x18 = -x2
    x19 = -x3
    x20 = x11 + x14 + x15 + x17 + x18 + x19 + 3
    x21 = -x1 - x4 + x8
    x22 = x12 + x21 + x7 + x9
    x23 = -x0 - x5 + 2*x_0_1*x_2_3
    x24 = x10*x_0_1 + x10*x_1_3 + x16*x_0_1
    x25 = x23 + x24
    x26 = x6*x_0_1
    x27 = x13*x_0_1
    x28 = x6*x_1_2
    x29 = x23 + x26 + x27 + x28 + 3
    x30 = x11 + x18 + x19

    # Final calculations
    result = -2*x0 - 2*x1 - 2*x11*x_0_1 - 2*x11*x_1_3 - 2*x11*x_2_3 - 2*x12*x_0_1 - 2*x12*x_1_3 - 2*x14*x_0_1 - 2*x15*x_0_1 - 2*x17*x_0_1 - 2*x2 - 2*x3 - 2*x4 - 2*x5 - 2*x7*x_0_1 - 2*x7*x_1_2 - 2*x7*x_1_3 - 2*x8*x_0_1 - 2*x8*x_1_2 - 2*x8*x_2_3 - 2*x9*x_0_1 - 2*x9*x_1_2 + 6*x_0_1*x_0_2 + 6*x_0_1*x_0_3 + 6*x_0_1*x_1_2 + 6*x_0_1*x_1_3 + 8*x_0_1*x_2_3 + 6*x_0_2*x_0_3 + 6*x_0_2*x_1_2 + 8*x_0_2*x_1_3 + 6*x_0_2*x_2_3 + 8*x_0_3*x_1_2 + 6*x_0_3*x_1_3 + 6*x_0_3*x_2_3 + 6*x_1_2*x_1_3 + 6*x_1_2*x_2_3 + 6*x_1_3*x_2_3 + 4
    gradient = np.array([
        -2*x20 - 2*x22 + 8*x_2_3,
        -2*x20 - 2*x25 + 8*x_1_3,
        -2*x14 - 2*x15 - 2*x17 - 2*x21 - 2*x29 + 8*x_1_2,
        -2*x22 - 2*x25 + 8*x_0_3 - 6,
        -2*x12 - 2*x29 - 2*x30 - 2*x7 - 2*x9 + 8*x_0_2,
        -2*x21 - 2*x24 - 2*x26 - 2*x27 - 2*x28 - 2*x30 + 8*x_0_1 - 6
    ])
    
    return result, gradient



# --------------------------------------------------------------------------
# Combined Value and Jacobian Function (S4_n4)
# Generated for use with scipy.optimize.minimize(..., jac=True)
# --------------------------------------------------------------------------
@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S4_n4_value_and_jac(x_vec):
    """Calculates both the value and Jacobian of S_4 for n=4.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_0_3, x_1_2, x_1_3, x_2_3

    Returns:
        (float, numpy.ndarray): A tuple containing the S_4 value and its gradient.
    """
    # Assign variables from input vector
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_0_3 = x_vec[2]
    x_1_2 = x_vec[3]
    x_1_3 = x_vec[4]
    x_2_3 = x_vec[5]

    # Common subexpressions for value and gradient
    x0 = 4*x_2_3
    x1 = x0*x_0_1
    x2 = 4*x_1_3
    x3 = x2*x_0_2
    x4 = 4*x_1_2
    x5 = x4*x_0_3
    x6 = 4*x_0_3
    x7 = x6*x_0_2
    x8 = x2*x_1_2
    x9 = x0*x_0_2
    x10 = x0*x_0_3
    x11 = -3*x_0_3
    x12 = -3*x_1_2
    x13 = x0*x_1_2
    x14 = x0*x_1_3
    x15 = x11 + x12 + x13 + x14 + x5 + x8 + 2
    x16 = x3 - 3*x_0_2 - 3*x_1_3
    x17 = x10 + x16 + x7 + x9
    x18 = x1 - 3*x_0_1 - 3*x_2_3
    x19 = x2*x_0_1 + x2*x_0_3 + x6*x_0_1
    x20 = x18 + x19
    x21 = 4*x_0_1*x_0_2
    x22 = x4*x_0_1
    x23 = x4*x_0_2
    x24 = x18 + x21 + x22 + x23 + 2
    x25 = x11 + x12 + x5

    # Final calculations
    result = -x1*x_0_2 - x1*x_0_3 - x1*x_1_2 - x1*x_1_3 + x1 - x10*x_1_2 - x10*x_1_3 - x3*x_0_1 - x3*x_0_3 - x3*x_1_2 + x3 - x5*x_0_1 - x5*x_0_2 + x5 - x7*x_0_1 - x8*x_0_1 - x8*x_0_3 - x9*x_1_2 - x9*x_1_3 + 3*x_0_1*x_0_2 + 3*x_0_1*x_0_3 + 3*x_0_1*x_1_2 + 3*x_0_1*x_1_3 - 2*x_0_1 + 3*x_0_2*x_0_3 + 3*x_0_2*x_1_2 + 3*x_0_2*x_2_3 - 2*x_0_2 + 3*x_0_3*x_1_3 + 3*x_0_3*x_2_3 - 2*x_0_3 + 3*x_1_2*x_1_3 + 3*x_1_2*x_2_3 - 2*x_1_2 + 3*x_1_3*x_2_3 - 2*x_1_3 - 2*x_2_3 + 1
    gradient = np.array([
        -x15 - x17 + 4*x_2_3,
        -x15 - x20 + 4*x_1_3,
        -x13 - x14 - x16 - x24 - x8 + 4*x_1_2,
        -x17 - x20 + 4*x_0_3 - 2,
        -x10 - x24 - x25 - x7 - x9 + 4*x_0_2,
        -x16 - x19 - x21 - x22 - x23 - x25 + 4*x_0_1 - 2
    ])
    
    return result, gradient


