# -*- coding: utf-8 -*-
# Symbolic Functions for N = 3 (matrix_type='niep')
# Generated by symbolic_minors_generator.py using Newton's Sums
# DO NOT EDIT MANUALLY

import math
import numpy as np
import numba


# --------------------------------------------------------------------------
# Value Function (S1_n3)
# Input: x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
# --------------------------------------------------------------------------
@numba.jit(nopython=True)
def calculate_S1_n3(x_vec):
    """Calculates S_1 for n=3 using generated symbolic expressions.
    This function is JIT-compiled with Numba for performance.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
    
    Returns:
        float: The value of S_1.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_0 = x_vec[2]
    x_1_2 = x_vec[3]
    x_2_0 = x_vec[4]
    x_2_1 = x_vec[5]
    # S_k CSE Defs

    # Final S_k Calculation
    result = -x_0_1 - x_0_2 - x_1_0 - x_1_2 - x_2_0 - x_2_1 + 3
    return result



# --------------------------------------------------------------------------
# Jacobian Function (S1_n3)
# Input: x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
# --------------------------------------------------------------------------
@numba.jit(nopython=True)
def calculate_S1_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_1 for n=3.
    This function is JIT-compiled with Numba for performance.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
    
    Returns:
        numpy.ndarray: The gradient vector of S_1.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_0 = x_vec[2]
    x_1_2 = x_vec[3]
    x_2_0 = x_vec[4]
    x_2_1 = x_vec[5]
    # Jacobian CSE Defs

    # Final Gradient Calculation
    gradient = np.array([
        -1,
        -1,
        -1,
        -1,
        -1,
        -1
    ])
    return gradient



# --------------------------------------------------------------------------
# Value Function (S2_n3)
# Input: x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
# --------------------------------------------------------------------------
@numba.jit(nopython=True)
def calculate_S2_n3(x_vec):
    """Calculates S_2 for n=3 using generated symbolic expressions.
    This function is JIT-compiled with Numba for performance.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
    
    Returns:
        float: The value of S_2.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_0 = x_vec[2]
    x_1_2 = x_vec[3]
    x_2_0 = x_vec[4]
    x_2_1 = x_vec[5]
    # S_k CSE Defs

    # Final S_k Calculation
    result = x_0_1*x_1_2 + x_0_1*x_2_0 + x_0_1*x_2_1 - 2*x_0_1 + x_0_2*x_1_0 + x_0_2*x_1_2 + x_0_2*x_2_1 - 2*x_0_2 + x_1_0*x_2_0 + x_1_0*x_2_1 - 2*x_1_0 + x_1_2*x_2_0 - 2*x_1_2 - 2*x_2_0 - 2*x_2_1 + 3
    return result



# --------------------------------------------------------------------------
# Jacobian Function (S2_n3)
# Input: x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
# --------------------------------------------------------------------------
@numba.jit(nopython=True)
def calculate_S2_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_2 for n=3.
    This function is JIT-compiled with Numba for performance.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
    
    Returns:
        numpy.ndarray: The gradient vector of S_2.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_0 = x_vec[2]
    x_1_2 = x_vec[3]
    x_2_0 = x_vec[4]
    x_2_1 = x_vec[5]
    # Jacobian CSE Defs
    x0 = x_2_0 - 2
    x1 = x_1_2 + x_2_1
    x2 = x_1_0 - 2
    x3 = x0 + x_0_2
    x4 = x2 + x_0_1
    # Final Gradient Calculation
    gradient = np.array([
        x0 + x1,
        x1 + x2,
        x3 + x_2_1,
        x3 + x_0_1,
        x4 + x_1_2,
        x4 + x_0_2
    ])
    return gradient



# --------------------------------------------------------------------------
# Value Function (S3_n3)
# Input: x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
# --------------------------------------------------------------------------
@numba.jit(nopython=True)
def calculate_S3_n3(x_vec):
    """Calculates S_3 for n=3 using generated symbolic expressions.
    This function is JIT-compiled with Numba for performance.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
    
    Returns:
        float: The value of S_3.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_0 = x_vec[2]
    x_1_2 = x_vec[3]
    x_2_0 = x_vec[4]
    x_2_1 = x_vec[5]
    # S_k CSE Defs

    # Final S_k Calculation
    result = x_0_1*x_1_2 + x_0_1*x_2_0 + x_0_1*x_2_1 - x_0_1 + x_0_2*x_1_0 + x_0_2*x_1_2 + x_0_2*x_2_1 - x_0_2 + x_1_0*x_2_0 + x_1_0*x_2_1 - x_1_0 + x_1_2*x_2_0 - x_1_2 - x_2_0 - x_2_1 + 1
    return result



# --------------------------------------------------------------------------
# Jacobian Function (S3_n3)
# Input: x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
# --------------------------------------------------------------------------
@numba.jit(nopython=True)
def calculate_S3_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_3 for n=3.
    This function is JIT-compiled with Numba for performance.

    Args:
        x_vec (numpy.ndarray): Input vector of length 6
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_0, x_1_2, x_2_0, x_2_1
    
    Returns:
        numpy.ndarray: The gradient vector of S_3.
    """
    # Assign vars
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_0 = x_vec[2]
    x_1_2 = x_vec[3]
    x_2_0 = x_vec[4]
    x_2_1 = x_vec[5]
    # Jacobian CSE Defs
    x0 = x_2_0 - 1
    x1 = x_1_2 + x_2_1
    x2 = x_1_0 - 1
    x3 = x0 + x_0_2
    x4 = x2 + x_0_1
    # Final Gradient Calculation
    gradient = np.array([
        x0 + x1,
        x1 + x2,
        x3 + x_2_1,
        x3 + x_0_1,
        x4 + x_1_2,
        x4 + x_0_2
    ])
    return gradient


