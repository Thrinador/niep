# -*- coding: utf-8 -*-
# Combined Value & Jacobian Functions for N = 3 (matrix_type='sniep')
# Generated by symbolic_minors_generator.py using Newton's Sums
# Optimized for use with scipy.optimize.minimize(..., jac=True)
# DO NOT EDIT MANUALLY

import numpy as np
import numba
# The 'math' module is not needed as Numba recognizes standard functions


# --------------------------------------------------------------------------
# Combined Value and Jacobian Function (S1_n3)
# Generated for use with scipy.optimize.minimize(..., jac=True)
# --------------------------------------------------------------------------
@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n3_value_and_jac(x_vec):
    """Calculates both the value and Jacobian of S_1 for n=3.

    Args:
        x_vec (numpy.ndarray): Input vector of length 3
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_2

    Returns:
        (float, numpy.ndarray): A tuple containing the S_1 value and its gradient.
    """
    # Assign variables from input vector
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    # Common subexpressions for value and gradient


    # Final calculations
    result = -2*x_0_1 - 2*x_0_2 - 2*x_1_2 + 3
    gradient = np.array([
        -2,
        -2,
        -2
    ])
    
    return result, gradient



# --------------------------------------------------------------------------
# Combined Value and Jacobian Function (S2_n3)
# Generated for use with scipy.optimize.minimize(..., jac=True)
# --------------------------------------------------------------------------
@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n3_value_and_jac(x_vec):
    """Calculates both the value and Jacobian of S_2 for n=3.

    Args:
        x_vec (numpy.ndarray): Input vector of length 3
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_2

    Returns:
        (float, numpy.ndarray): A tuple containing the S_2 value and its gradient.
    """
    # Assign variables from input vector
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    # Common subexpressions for value and gradient
    x0 = 3*x_0_2
    x1 = 3*x_1_2
    x2 = x1 - 4
    x3 = 3*x_0_1

    # Final calculations
    result = x0*x_0_1 + x0*x_1_2 + x1*x_0_1 - 4*x_0_1 - 4*x_0_2 - 4*x_1_2 + 3
    gradient = np.array([
        x0 + x2,
        x2 + x3,
        x0 + x3 - 4
    ])
    
    return result, gradient



# --------------------------------------------------------------------------
# Combined Value and Jacobian Function (S3_n3)
# Generated for use with scipy.optimize.minimize(..., jac=True)
# --------------------------------------------------------------------------
@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n3_value_and_jac(x_vec):
    """Calculates both the value and Jacobian of S_3 for n=3.

    Args:
        x_vec (numpy.ndarray): Input vector of length 3
           containing the variable matrix elements in the specified order:
                      x_0_1, x_0_2, x_1_2

    Returns:
        (float, numpy.ndarray): A tuple containing the S_3 value and its gradient.
    """
    # Assign variables from input vector
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    # Common subexpressions for value and gradient
    x0 = 3*x_0_2
    x1 = 3*x_1_2
    x2 = x1 - 2
    x3 = 3*x_0_1

    # Final calculations
    result = x0*x_0_1 + x0*x_1_2 + x1*x_0_1 - 2*x_0_1 - 2*x_0_2 - 2*x_1_2 + 1
    gradient = np.array([
        x0 + x2,
        x2 + x3,
        x0 + x3 - 2
    ])
    
    return result, gradient


