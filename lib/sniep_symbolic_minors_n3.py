# -*- coding: utf-8 -*-
# Separated Value, Jacobian, & Hessian Functions for N = 3 (matrix_type='sniep')
# Generated by symbolic_minors_generator.py
# DO NOT EDIT MANUALLY

import numpy as np
import numba

# --- Functions for S_1 ---

@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n3(x_vec):
    """Calculates the value of S_1 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    return -2*x_0_1 - 2*x_0_2 - 2*x_1_2 + 3



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_1 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    return np.array([-2,
        -2,
        -2])



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S1_n3_hessian(x_vec):
    """Calculates the Hessian matrix of S_1 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    hessian = np.empty((3, 3))
    hessian[0, 0] = 0
    hessian[0, 1] = 0
    hessian[0, 2] = 0
    hessian[1, 0] = 0
    hessian[1, 1] = 0
    hessian[1, 2] = 0
    hessian[2, 0] = 0
    hessian[2, 1] = 0
    hessian[2, 2] = 0
    return hessian


# --- Functions for S_2 ---

@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n3(x_vec):
    """Calculates the value of S_2 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]
    x0 = 3*x_0_1
    return x0*x_0_2 + x0*x_1_2 - 4*x_0_1 + 3*x_0_2*x_1_2 - 4*x_0_2 - 4*x_1_2 + 3



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_2 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]
    x0 = 3*x_0_2
    x1 = 3*x_1_2 - 4
    x2 = 3*x_0_1
    return np.array([x0 + x1,
        x1 + x2,
        x0 + x2 - 4])



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S2_n3_hessian(x_vec):
    """Calculates the Hessian matrix of S_2 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    hessian = np.empty((3, 3))
    hessian[0, 0] = 0
    hessian[0, 1] = 3
    hessian[0, 2] = 3
    hessian[1, 0] = 3
    hessian[1, 1] = 0
    hessian[1, 2] = 3
    hessian[2, 0] = 3
    hessian[2, 1] = 3
    hessian[2, 2] = 0
    return hessian


# --- Functions for S_3 ---

@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n3(x_vec):
    """Calculates the value of S_3 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]
    x0 = 3*x_0_1
    return x0*x_0_2 + x0*x_1_2 - 2*x_0_1 + 3*x_0_2*x_1_2 - 2*x_0_2 - 2*x_1_2 + 1



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n3_jacobian(x_vec):
    """Calculates the Jacobian of S_3 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]
    x0 = 3*x_0_2
    x1 = 3*x_1_2 - 2
    x2 = 3*x_0_1
    return np.array([x0 + x1,
        x1 + x2,
        x0 + x2 - 2])



@numba.jit(nopython=True, fastmath=True, cache=True)
def calculate_S3_n3_hessian(x_vec):
    """Calculates the Hessian matrix of S_3 for n=3."""
    x_0_1 = x_vec[0]
    x_0_2 = x_vec[1]
    x_1_2 = x_vec[2]

    hessian = np.empty((3, 3))
    hessian[0, 0] = 0
    hessian[0, 1] = 3
    hessian[0, 2] = 3
    hessian[1, 0] = 3
    hessian[1, 1] = 0
    hessian[1, 2] = 3
    hessian[2, 0] = 3
    hessian[2, 1] = 3
    hessian[2, 2] = 0
    return hessian


